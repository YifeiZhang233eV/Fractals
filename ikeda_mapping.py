# -*- coding: utf-8 -*-
"""Ikeda_Mapping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1caP4gGkSBXjaZoaKE3XZPc99tvXVnYiM

**GPU Allocation of Parameters and Data:**

In the code, we allocate all the parameters (A, B, kappa, rho) and the initial points (z) to the GPU (device). This ensures that all subsequent calculations can be performed in parallel on the GPU rather than sequentially on the CPU. PyTorch automatically distributes these computational tasks across multiple cores on the GPU, thereby accelerating the computation.

**Parallel Computation of the Ikeda Map:**

During each iteration, the system updates all the initial points simultaneously. This is executed in parallel on the GPU. Since the computation for each point is independent, the GPU's parallel computing power can be leveraged to process multiple points simultaneously. This significantly improves computational efficiency, especially when a large number of iterations are required.

**Fractal**

Since it lacks strict self-similarity, this image should not be considered a fractal. However, it visually resembles one because it exhibits a high degree of complexity, infinite detail, and the shape also shows a pattern similar to a vortex.
"""

import torch
import numpy as np
import matplotlib.pyplot as plt

# Confirm the device to use (GPU if available, otherwise CPU)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Create the initial points in the complex plane [-4, 4] x [-4, 4]
Y, X = np.mgrid[-4:4:0.005, -4:4:0.005]

# Load the NumPy arrays into PyTorch tensors
x = torch.Tensor(X)
y = torch.Tensor(Y)
z = torch.complex(x, y)  # Important step: Combine x and y into a complex number z

# Fixed parameters for the Ikeda map
A = torch.tensor(0.9)
B = torch.tensor(0.9)
kappa = torch.tensor(0.4)
rho = torch.tensor(6.0)

# Initialize a copy of z and the iteration count
zs = z.clone()
ns = torch.zeros_like(z)

# Transfer the tensors to the GPU device
z = z.to(device)
zs = zs.to(device)
ns = ns.to(device)

# Compute the Ikeda map
for i in range(1000):  # Number of iterations
    theta_n = kappa - rho / (1 + torch.abs(zs)**2)
    zs_ = A + B * zs * torch.exp(1j * theta_n)
    not_diverged = torch.abs(zs_) < 4.0  # Check if the point has diverged
    ns += not_diverged
    zs = zs_

# Plotting section
fig = plt.figure(figsize=(16,10))

def processFractal(a):
    """Display an array of iteration counts as a
    colorful picture of a fractal."""

    if np.iscomplexobj(a):  # Handle complex number warning
        a = np.abs(a)

    a_cyclic = (6.28*a/20.0).reshape(list(a.shape)+[1])
    img = np.concatenate([10+20*np.cos(a_cyclic),
                          30+50*np.sin(a_cyclic),
                          155-80*np.cos(a_cyclic)], 2)
    img[a == a.max()] = 0
    a = img
    a = np.uint8(np.clip(a, 0, 255))
    return a

plt.imshow(processFractal(ns.cpu().numpy()))  # Move tensor back to CPU for plotting
plt.tight_layout(pad=0)
plt.show()